/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.bdawg.metalbgp

import com.bdawg.metalbgp.fetcher.MetalFetcher
import com.bdawg.metalbgp.unifi.provision.UnifiProvisioner
import com.bdawg.metalbgp.unifi.provision.UnifiSnippetEmitter
import com.bdawg.metalbgp.unifi.sync.UnifiConfigMerger
import com.bdawg.metalbgp.unifi.sync.UnifiConfigPull
import java.io.File
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.default
import kotlinx.cli.multiple
import kotlinx.coroutines.runBlocking
import mu.KotlinLogging

data class MetalConfig(val speakerDaemonSetName: String, val metalNamespace: String)

data class UnifiControllerConfig(
    val controllerIp: String,
    val unifiOsProxy: Boolean,
    val unifiUsername: String,
    val unifiPassowrd: String,
    val unifiSshUsername: String,
    val unifiSshPassword: String,
    val unifiConfigLocation: String = "/srv/unifi/data/sites/default/config.gateway.json",
    val siteName: String
)

data class MetalUnfiBgpSyncConfig(
    val kubeConfigPath: String?,
    val metalConfig: MetalConfig,
    val unifiConfig: UnifiControllerConfig,
    val dryRun: Boolean
)

class App(val config: MetalUnfiBgpSyncConfig) {
  private val logger = KotlinLogging.logger {}

  /**
   * Run the sync job
   *
   * This will:
   * - Get the config from metal / k8s
   * - Turn it in to a unifi based config
   * - Push this to the unifi controller
   * - Initiate a provision for the router
   */
  suspend fun run() {
    logger.info { "Fetching metal data from k8s" }
    val metalConfigs = MetalFetcher(config).fetch()
    logger.info { "Fetched ${metalConfigs.size} metal configs from k8s" }
    val metalConfigsByRouter = metalConfigs.groupBy { it.routerAddress }
    logger.info { "There are  ${metalConfigsByRouter.size} metal configs by router" }
    metalConfigsByRouter.forEach {
      logger.info { "Updating router at ${it.key} with new metal config" }
      val metalUnifiJson = UnifiSnippetEmitter(it.value).buildUnifiJsonSnippet()
      logger.debug { "Metal Unifi json: $metalUnifiJson" }
      val controllerConfig = UnifiConfigPull(config).getControllerConfig()
      val controllerConfigJson =
          String(Files.readAllBytes(controllerConfig.toPath()), StandardCharsets.UTF_8)
      val mergedWithController = UnifiConfigMerger().merge(metalUnifiJson, controllerConfigJson)
      logger.info { "Merged controller config: ${mergedWithController}" }
      if (!config.dryRun) {
        logger.info { "Not a dry run - pushing new config" }
        val mergedJsonFile = File.createTempFile("merge-unifi", "json")
        Files.write(
            mergedJsonFile.toPath(), mergedWithController.toByteArray(StandardCharsets.UTF_8))
        UnifiConfigPull(config).putControllerConfig(mergedJsonFile)
        logger.info { "Persisted new config to controller - provisioning router" }
        UnifiProvisioner(config).doProvision(it.key)
        logger.info { "Done - Provision completed successfully. I love you." }
      } else {
        logger.info { "Dry run mode - nothing to do. I still love you though." }
      }
    }
  }
}

fun main(args: Array<String>) {
  val parser = ArgParser("metal-unifi-bgp-sync")
  val localAsns by
      parser
          .option(
              ArgType.String,
              shortName = "a",
              description =
                  "MetalASN - MetalBGP ASNs to sync - optional. Otherwise all discovered ASNs will be used",
              fullName = "asn")
          .multiple()
  val dryRun by
      parser
          .option(
              ArgType.Boolean,
              shortName = "d",
              description = "Turn off dry run mode [ default dry run ]")
          .default(true)
  val kubeConfigPath by
      parser
          .option(ArgType.String, shortName = "c", description = "Kube config path")
          .default(System.getenv("HOME") + "/.kube/config")
  val speakerDaemonSetName by
      parser
          .option(ArgType.String, shortName = "s", description = "Speaker daemon set name")
          .default("speaker")
  val metalNamespace by
      parser
          .option(ArgType.String, shortName = "m", description = "MetalLB namespace")
          .default("metallb-system")
  parser.parse(args)

  val config =
      MetalUnfiBgpSyncConfig(
          kubeConfigPath = kubeConfigPath,
          metalConfig =
              MetalConfig(
                  speakerDaemonSetName = speakerDaemonSetName, metalNamespace = metalNamespace),
          unifiConfig =
              UnifiControllerConfig(
                  controllerIp = "",
                  unifiOsProxy = true,
                  unifiUsername = "",
                  unifiPassowrd = "",
                  siteName = "default",
                  unifiSshUsername = "",
                  unifiSshPassword = ""),
          dryRun = dryRun)
  val app = App(config)
  val result = runBlocking { app.run() }
}
