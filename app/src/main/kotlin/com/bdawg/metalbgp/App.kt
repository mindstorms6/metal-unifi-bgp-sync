/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.bdawg.metalbgp

import com.bdawg.metalbgp.fetcher.MetalFetcher
import com.bdawg.metalbgp.unifi.provision.UnifiProvisioner
import com.bdawg.metalbgp.unifi.provision.UnifiSnippetEmitter
import com.bdawg.metalbgp.unifi.sync.UnifiConfigMerger
import com.bdawg.metalbgp.unifi.sync.UnifiConfigPull
import java.io.File
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import kotlinx.cli.*
import kotlinx.coroutines.runBlocking
import mu.KotlinLogging

data class MetalConfig(val speakerDaemonSetName: String, val metalNamespace: String)

data class UnifiControllerConfig(
    val controllerIp: String,
    val unifiOsProxy: Boolean,
    val unifiUsername: String,
    val unifiPassowrd: String,
    val unifiSshUsername: String,
    val unifiSshPassword: String,
    val unifiConfigLocation: String = "/srv/unifi/data/sites/default/config.gateway.json",
    val siteName: String
)

data class MetalUnfiBgpSyncConfig(
    val kubeConfigPath: String?,
    val metalConfig: MetalConfig,
    val unifiConfig: UnifiControllerConfig,
    val dryRun: Boolean
)

class App(val config: MetalUnfiBgpSyncConfig) {
  private val logger = KotlinLogging.logger {}

  /**
   * Run the sync job
   *
   * This will:
   * - Get the config from metal / k8s
   * - Turn it in to a unifi based config
   * - Push this to the unifi controller
   * - Initiate a provision for the router
   */
  suspend fun run() {
    logger.info { "Fetching metal data from k8s" }
    val metalConfigs = MetalFetcher(config).fetch()
    logger.info { "Fetched ${metalConfigs.size} metal configs from k8s" }
    val metalConfigsByRouter = metalConfigs.groupBy { it.routerAddress }
    logger.info { "There are  ${metalConfigsByRouter.size} metal configs by router" }
    metalConfigsByRouter.forEach {
      logger.info { "Updating router at ${it.key} with new metal config" }
      val metalUnifiJson = UnifiSnippetEmitter(it.value).buildUnifiJsonSnippet()
      logger.debug { "Metal Unifi json: $metalUnifiJson" }
      val controllerConfig = UnifiConfigPull(config).getControllerConfig()
      val controllerConfigJson =
          String(Files.readAllBytes(controllerConfig.toPath()), StandardCharsets.UTF_8)
      logger.info { "Current controller config: $controllerConfigJson" }
      val mergedWithController = UnifiConfigMerger().merge(metalUnifiJson, controllerConfigJson)
      logger.info { "Merged controller config: $mergedWithController" }
      val mergedJsonFile = File.createTempFile("merge-unifi", "json")
      Files.write(mergedJsonFile.toPath(), mergedWithController.toByteArray(StandardCharsets.UTF_8))
      if (!config.dryRun) {
        logger.info { "Not a dry run - pushing new config" }
        UnifiConfigPull(config).putControllerConfig(mergedJsonFile)
        logger.info { "Persisted new config to controller - provisioning router" }
        UnifiProvisioner(config).doProvision(it.key)
        logger.info { "Done - Provision completed successfully. I love you." }
      } else {

        logger.info {
          "Dry run mode - nothing to do. Wrote new merged config to ${mergedJsonFile.absolutePath} . I still love you though."
        }
      }
    }
  }
}

fun main(args: Array<String>) {
  val parser = ArgParser("metal-unifi-bgp-sync")
  val dryRun by
      parser
          .option(
              ArgType.Boolean,
              shortName = "d",
              description = "Turn off dry run mode [ default dry run ]")
          .default(true)
  val kubeConfigPath by
      parser
          .option(ArgType.String, shortName = "k", description = "Kube config path")
          .default(System.getenv("HOME") + "/.kube/config")
  val speakerDaemonSetName by
      parser
          .option(ArgType.String, shortName = "s", description = "Speaker daemon set name")
          .default("speaker")
  val metalNamespace by
      parser
          .option(ArgType.String, shortName = "m", description = "MetalLB namespace")
          .default("metallb-system")
  val unifiControllerIp by
      parser
          .option(ArgType.String, shortName = "c", description = "Controller IP address")
          .required()
  val unifiOsProxy by
      parser
          .option(
              ArgType.Boolean,
              shortName = "p",
              description =
                  "If your controller runs on UnifiOS and needs the proxy prefix (UDMP, CloudKey, etc)")
          .default(true)
  val unifiSiteName by
      parser
          .option(ArgType.String, shortName = "sn", description = "Unifi site name")
          .default("default")
  val unifiControllerUsername by
      parser
          .option(ArgType.String, shortName = "cu", description = "Unifi controller username")
          .required()
  val unifiControllerPassword by
      parser
          .option(ArgType.String, shortName = "cp", description = "Unifi controller password")
          .required()
  val unifiSshUsername by
      parser
          .option(ArgType.String, shortName = "sshu", description = "Unifi ssh username")
          .required()
  val unifiSshPassword by
      parser
          .option(ArgType.String, shortName = "sshp", description = "Unifi ssh password")
          .required()
  parser.parse(args)

  val config =
      MetalUnfiBgpSyncConfig(
          kubeConfigPath = kubeConfigPath,
          metalConfig =
              MetalConfig(
                  speakerDaemonSetName = speakerDaemonSetName, metalNamespace = metalNamespace),
          unifiConfig =
              UnifiControllerConfig(
                  controllerIp = unifiControllerIp,
                  unifiOsProxy = unifiOsProxy,
                  unifiUsername = unifiControllerUsername,
                  unifiPassowrd = unifiControllerPassword,
                  siteName = unifiSiteName,
                  unifiSshUsername = unifiSshUsername,
                  unifiSshPassword = unifiSshPassword),
          dryRun = dryRun)
  val app = App(config)
  val result = runBlocking { app.run() }
}
